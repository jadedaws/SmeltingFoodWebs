---
title: "SIBER/NicheROVER"
author: "J Dawson"
date: '2021-05-14'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Importing Data}
rm(list=ls())

library(naniar)
library(dplyr)
library(ggplot2)
library(readr)

```

#CALCULATING MEAN NICHE SEPARATION/OVERLAP AND ELLIPSE SIZES#
#run this, note SEAc and SEAb
#then re-assign communities so ref lakes separate
#then re-run, note SEAc and SEAb, take mean for ref lakes

```{r Ellipse area}
library(SIBER)
library(magrittr)
library(nicheROVER)
library(viridis)

####import new SIBER dat, make 2 df, one p_lit, one adjp_lit, rename iso1, iso2, group, community columns for both

siberdat <- read_csv("../data/test1.csv")
siberdat <- siberdat %>%
  subset(select = c("plit_bound", "tp_2", "TAXON", "Water")) %>%
  rename("iso1" = "plit_bound",
         "iso2" = "tp_2",
         "group" = "TAXON",
         "community" = "Water") %>%
  na.omit()
siberdat <- siberdat %>%
  subset(group %in% c("SMB", "YPERCH"))

#formatting community to integers ###add ref as sep lines
siberdat$community[siberdat$community == "Barren Lake"] <- 1
siberdat$community[siberdat$community == "Semi-barren Lake"] <- 2
siberdat$community[siberdat$community == "Forested Lake"] <- 3
siberdat$community[siberdat$community == "Reference"] <- 4
siberdat$community <- as.integer(siberdat$community)
#formatting group as integers
siberdat$group[siberdat$group == "SMB"] <- 1
siberdat$group[siberdat$group == "YPERCH"] <- 2
siberdat$group <- as.integer(siberdat$group)
siberdat <- as.data.frame(siberdat)

siber.obj <- createSiberObject(siberdat)

community.hulls.args <- list(col = 1, lty = 1, lwd = 1)
group.ellipses.args <- list(n = 100, p.interval = 0.95, lty = 1, lwd = 2)
group.hulls.args <- list(lty = 2, col = "grey20")

par(mfrow=c(1,1))
plotSiberObject(siber.obj,
                ax.pad = 2,
                hulls = F, community.hulls.args = community.hulls.args,
                ellipses = T, group.ellipses.args = group.ellipses.args,
                group.hulls = F, group.hulls.args = group.hulls.args,
                bty = "L",
                iso.order = c(1,2),
                xlab = "Adjusted PL norm",
                ylab = "Trophic Position"
                )
#plotSiberObject(siber.obj,
                  ax.pad = 2, 
                  hulls = F, community.hulls.args = community.hulls.args, 
                  ellipses = T, group.ellipses.args = group.ellipses.args,
                  group.hulls = F, group.hulls.args = group.hulls.args,
                  bty = "L",
                  iso.order = c(1,2),
                  xlab = expression({delta}^13*C~'\u2030'),
                  ylab = expression({delta}^15*N~'\u2030')
                  )

#species in each lake
group.ML <- groupMetricsML(siber.obj)
print(group.ML)

#by lake
community.ML <- communityMetricsML(siber.obj) 
print(community.ML)



```

```{r defining Ellipses for overlap}
# defining ellipses. dy = Daisy Lake, bb = Baby Lake, nl = Nelson Lake, ref = Reference; yp = yellow perch, smb = smallmouth bass.
#bb smb
ellipse1 <- "1.1" 
#bb yp
ellipse2 <- "1.2"
#dy smb
ellipse3 <- "2.1"
#dy yp
ellipse4 <- "2.2"
#nl smb
ellipse5 <- "3.1"
#nl yp
ellipse6 <- "3.2"
#ref smb
ellipse7 <- "4.1"
#ref yp
ellipse8 <- "4.2"

```

```{r Ellipse overlap - max likelihood}
###################
###   BABY LK  ###
###################
# The overlap of the maximum likelihood fitted standard ellipses are estimated using
bb.overlap <- maxLikOverlap(ellipse1, ellipse2, siber.obj, 
                             p.interval = NULL, n = 100)
# the overlap betweeen the corresponding 95% prediction ellipses is given by:
bb.ellipse95.overlap <- maxLikOverlap(ellipse1, ellipse2, siber.obj, 
                             p.interval = 0.95, n = 100)
# so in this case, the overlap as a proportion of the non-overlapping area of the two ellipses, would be
bb.prop.95.over <- bb.ellipse95.overlap[3] / (bb.ellipse95.overlap[2] + 
                                          bb.ellipse95.overlap[1] -
                                          bb.ellipse95.overlap[3])

###################
###   DAISY LK   ###
###################
dy.overlap <- maxLikOverlap(ellipse3, ellipse4, siber.obj, 
                             p.interval = NULL, n = 100)
dy.ellipse95.overlap <- maxLikOverlap(ellipse3, ellipse4, siber.obj, 
                             p.interval = 0.95, n = 100)
dy.prop.95.over <- dy.ellipse95.overlap[3] / (dy.ellipse95.overlap[2] + 
                                          dy.ellipse95.overlap[1] -
                                         dy.ellipse95.overlap[3])

###################
##  NELSON LK   ###
###################
nl.overlap <- maxLikOverlap(ellipse5, ellipse6, siber.obj, 
                             p.interval = NULL, n = 100)
nl.ellipse95.overlap <- maxLikOverlap(ellipse5, ellipse6, siber.obj, 
                             p.interval = 0.95, n = 100)
nl.prop.95.over <- nl.ellipse95.overlap[3] / (nl.ellipse95.overlap[2] + 
                                          nl.ellipse95.overlap[1] -
                                         nl.ellipse95.overlap[3])

###################
#  REFERENCE LKs  #
###################
ref.overlap <- maxLikOverlap(ellipse7, ellipse8, siber.obj, 
                             p.interval = NULL, n = 100)
ref.ellipse95.overlap <- maxLikOverlap(ellipse7, ellipse8, siber.obj, 
                             p.interval = 0.95, n = 100)
ref.prop.95.over <- ref.ellipse95.overlap[3] / (ref.ellipse95.overlap[2] + 
                                          ref.ellipse95.overlap[1] -
                                         ref.ellipse95.overlap[3])

```

```{r test plots}
siberdat$community <- as.factor(siberdat$community)
siberdat$group <- as.factor(siberdat$group)

#exclude pts
ggplot(siberdat, aes(x = iso1, y = iso2, group = group, colour = group)) +
  #geom_point() +
  stat_ellipse(type = "norm", level = 0.4, lwd = 1.5) +
  theme_classic(base_size = 14) +
  facet_wrap(~community) +
  labs(title = "40% Ellipse")

```

```{r Bayesian}
# Fit the Bayesian models
library(rjags)

# options for running jags
parms <- list()
parms$n.iter <- 2 * 10^4   # number of iterations to run the model for
parms$n.burnin <- 1 * 10^3 # discard the first set of values
parms$n.thin <- 10     # thin the posterior by this many
parms$n.chains <- 2        # run this many chains

# define the priors
priors <- list()
priors$R <- 1 * diag(2)
priors$k <- 2
priors$tau.mu <- 1.0E-3

# fit the ellipses which uses an Inverse Wishart prior
# on the covariance matrix Sigma, and a vague normal prior on the 
# means. Fitting is via the JAGS method.
ellipses.posterior <- siberMVN(siber.obj, parms, priors)


# extract the posterior means
mu.post <- extractPosteriorMeans(siber.obj, ellipses.posterior)

# calculate the corresponding distribution of layman metrics
layman.B <- bayesianLayman(mu.post)


# --------------------------------------
# Visualise the first community
# --------------------------------------

# drop the 3rd column of the posterior which is TA using -3.
siberDensityPlot(layman.B[[1]][ , -3], 
                 xticklabels = colnames(layman.B[[1]][ , -3]), 
                 bty="L", ylim = c(0,20))

# add the ML estimates (if you want). Extract the correct means 
# from the appropriate array held within the overall array of means.
comm1.layman.ml <- laymanMetrics(siber.obj$ML.mu[[1]][1,1,],
                                 siber.obj$ML.mu[[1]][1,2,]
                                 )

# again drop the 3rd entry which relates to TA
points(1:5, comm1.layman.ml$metrics[-3], 
       col = "red", pch = "x", lwd = 2)

# --------------------------------------
# Visualise the second community
# --------------------------------------
siberDensityPlot(layman.B[[2]][ , -3], 
                 xticklabels = colnames(layman.B[[2]][ , -3]), 
                bty="L", ylim = c(0,20))

# add the ML estimates. (if you want) Extract the correct means 
# from the appropriate array held within the overall array of means.
comm2.layman.ml <- laymanMetrics(siber.obj$ML.mu[[2]][1,1,],
                                 siber.obj$ML.mu[[2]][1,2,]
                                )
points(1:5, comm2.layman.ml$metrics[-3], 
       col = "red", pch = "x", lwd = 2)

# --------------------------------------
# Alternatively, pull out TA from both and aggregate them into a 
# single matrix using cbind() and plot them together on one graph.
# --------------------------------------

# go back to a 1x1 panel plot
par(mfrow=c(1,1))

# Now we only plot the TA data. We could address this as either
# layman.B[[1]][, "TA"]
# or
# layman.B[[1]][, 3]
siberDensityPlot(cbind(layman.B[[1]][ , "TA"], 
                       layman.B[[2]][ , "TA"]),
                xticklabels = c("Community 1", "Community 2"), 
                bty="L", ylim = c(0, 90),
                las = 1,
                ylab = "TA - Convex Hull Area",
                xlab = "")
```
