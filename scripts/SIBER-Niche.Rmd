---
title: "SIBER/NicheROVER"
author: "J Dawson"
date: '2021-05-14'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Importing Data}
rm(list=ls())

library(naniar)
library(dplyr)
library(ggplot2)
library(readr)

```

#CALCULATING MEAN NICHE SEPARATION/OVERLAP AND ELLIPSE SIZES#
#run this, note SEAc and SEAb
#then re-assign communities so ref lakes separate
#then re-run, note SEAc and SEAb, take mean for ref lakes

```{r Ellipse area}
library(SIBER)
library(magrittr)
library(nicheROVER)
library(viridis)

####import new SIBER dat, make 2 df, one p_lit, one adjp_lit, rename iso1, iso2, group, community columns for both

siberdat <- read_csv("../data/siberdat_full.csv")
siberdat <- siberdat %>%
  subset(select = c("plit_bound", "tp_2", "TAXON", "Water")) %>%
  rename("iso1" = "plit_bound",
         "iso2" = "tp_2",
         "group" = "TAXON",
         "community" = "Water") %>%
  na.omit()
siberdat <- siberdat %>%
  subset(group %in% c("SMB", "YPERCH"))

#formatting community to integers
siberdat$community[siberdat$community == "Baby Lk."] <- 1
siberdat$community[siberdat$community == "Daisy Lk."] <- 2
siberdat$community[siberdat$community == "Nelson Lk."] <- 3
siberdat$community[siberdat$community == "Mendelssohn"] <- 4
siberdat$community[siberdat$community == "Turtleshell"] <- 5
siberdat$community[siberdat$community == "Manitou"] <- 6
siberdat$community[siberdat$community == "Wawiashkashi"] <- 7
siberdat$community[siberdat$community == "Stormy"] <- 8
siberdat$community <- as.integer(siberdat$community)
#formatting group as integers
siberdat$group[siberdat$group == "SMB"] <- 1
siberdat$group[siberdat$group == "YPERCH"] <- 2
siberdat$group <- as.integer(siberdat$group)
siberdat <- as.data.frame(siberdat)

siber.obj <- createSiberObject(siberdat)

community.hulls.args <- list(col = 1, lty = 1, lwd = 1)
group.ellipses.args <- list(n = 100, p.interval = 0.95, lty = 1, lwd = 2)
group.hulls.args <- list(lty = 2, col = "grey20")

par(mfrow=c(1,1))
plotSiberObject(siber.obj,
                ax.pad = 2,
                hulls = F, community.hulls.args = community.hulls.args,
                ellipses = T, group.ellipses.args = group.ellipses.args,
                group.hulls = F, group.hulls.args = group.hulls.args,
                bty = "L",
                iso.order = c(1,2),
                xlab = "Proportion Littoral",
                ylab = "Trophic Position"
                )


#species in each lake
group.ML <- groupMetricsML(siber.obj)
print(group.ML)

#by lake
community.ML <- communityMetricsML(siber.obj) 
print(community.ML)



```

```{r defining Ellipses for overlap}
# defining ellipses. dy = Daisy Lake, bb = Baby Lake, nl = Nelson Lake, men = Mendelssohn, ts = Turtleshell, man =  Manitou, ww = Wawiashkashi, st = Stormy; yp = yellow perch, smb = smallmouth bass.
#bb smb
ellipse1 <- "1.1" 
#bb yp
ellipse2 <- "1.2"
#dy smb
ellipse3 <- "2.1"
#dy yp
ellipse4 <- "2.2"
#nl smb
ellipse5 <- "3.1"
#nl yp
ellipse6 <- "3.2"
#men smb
ellipse7 <- "4.1"
#men yp
ellipse8 <- "4.2"
#ts smb
ellipse9 <- "5.1"
#ts yp
ellipse10 <- "5.2"
#man smb
ellipse11 <- "6.1"
#man yp
ellipse12 <- "6.2"
#ww smb
ellipse13 <- "7.1"
#ww yp
ellipse14 <- "7.2"
#st smb
ellipse15 <- "8.1"
#st yp
ellipse16 <- "8.2"

```

```{r Ellipse overlap - max likelihood}
###################
###   BABY LK  ###
###################
# The overlap of the maximum likelihood fitted standard ellipses are estimated using
bb.overlap <- maxLikOverlap(ellipse1, ellipse2, siber.obj, 
                             p.interval = NULL, n = 100)
# the overlap betweeen the corresponding 95% prediction ellipses is given by:
bb.ellipse95.overlap <- maxLikOverlap(ellipse1, ellipse2, siber.obj, 
                             p.interval = 0.95, n = 100)
# so in this case, the overlap as a proportion of the non-overlapping area of the two ellipses, would be
bb.prop.95.over <- bb.ellipse95.overlap[3] / (bb.ellipse95.overlap[2] + 
                                          bb.ellipse95.overlap[1] -
                                          bb.ellipse95.overlap[3])

###################
###   DAISY LK   ###
###################
dy.overlap <- maxLikOverlap(ellipse3, ellipse4, siber.obj, 
                             p.interval = NULL, n = 100)
dy.ellipse95.overlap <- maxLikOverlap(ellipse3, ellipse4, siber.obj, 
                             p.interval = 0.95, n = 100)
dy.prop.95.over <- dy.ellipse95.overlap[3] / (dy.ellipse95.overlap[2] + 
                                          dy.ellipse95.overlap[1] -
                                         dy.ellipse95.overlap[3])

###################
##  NELSON LK   ###
###################
nl.overlap <- maxLikOverlap(ellipse5, ellipse6, siber.obj, 
                             p.interval = NULL, n = 100)
nl.ellipse95.overlap <- maxLikOverlap(ellipse5, ellipse6, siber.obj, 
                             p.interval = 0.95, n = 100)
nl.prop.95.over <- nl.ellipse95.overlap[3] / (nl.ellipse95.overlap[2] + 
                                          nl.ellipse95.overlap[1] -
                                         nl.ellipse95.overlap[3])

###################
#   MENDELSSOHN   #
###################
men.overlap <- maxLikOverlap(ellipse7, ellipse8, siber.obj, 
                             p.interval = NULL, n = 100)
men.ellipse95.overlap <- maxLikOverlap(ellipse7, ellipse8, siber.obj, 
                             p.interval = 0.95, n = 100)
men.prop.95.over <- men.ellipse95.overlap[3] / (men.ellipse95.overlap[2] + 
                                          men.ellipse95.overlap[1] -
                                         men.ellipse95.overlap[3])

###################
#   TURTLESHELL   #
###################
ts.overlap <- maxLikOverlap(ellipse9, ellipse10, siber.obj, 
                             p.interval = NULL, n = 100)
ts.ellipse95.overlap <- maxLikOverlap(ellipse9, ellipse10, siber.obj, 
                             p.interval = 0.95, n = 100)
ts.prop.95.over <- ts.ellipse95.overlap[3] / (ts.ellipse95.overlap[2] + 
                                          ts.ellipse95.overlap[1] -
                                         ts.ellipse95.overlap[3])

###################
#     MANITOU     #
###################
man.overlap <- maxLikOverlap(ellipse11, ellipse12, siber.obj, 
                             p.interval = NULL, n = 100)
man.ellipse95.overlap <- maxLikOverlap(ellipse11, ellipse12, siber.obj, 
                             p.interval = 0.95, n = 100)
man.prop.95.over <- man.ellipse95.overlap[3] / (man.ellipse95.overlap[2] + 
                                          man.ellipse95.overlap[1] -
                                         man.ellipse95.overlap[3])

###################
#   WAWIASHKASHI  #
###################
ww.overlap <- maxLikOverlap(ellipse13, ellipse14, siber.obj, 
                             p.interval = NULL, n = 100)
ww.ellipse95.overlap <- maxLikOverlap(ellipse13, ellipse14, siber.obj, 
                             p.interval = 0.95, n = 100)
ww.prop.95.over <- ww.ellipse95.overlap[3] / (ww.ellipse95.overlap[2] + 
                                          ww.ellipse95.overlap[1] -
                                         ww.ellipse95.overlap[3])

###################
#     STORMY      #
###################
st.overlap <- maxLikOverlap(ellipse15, ellipse16, siber.obj, 
                             p.interval = NULL, n = 100)
st.ellipse95.overlap <- maxLikOverlap(ellipse15, ellipse16, siber.obj, 
                             p.interval = 0.95, n = 100)
st.prop.95.over <- st.ellipse95.overlap[3] / (st.ellipse95.overlap[2] + 
                                          st.ellipse95.overlap[1] -
                                         st.ellipse95.overlap[3])

```

```{r test plots}
siberdat$community <- as.factor(siberdat$community)
siberdat$group <- as.factor(siberdat$group)

#exclude pts
ggplot(siberdat, aes(x = iso1, y = iso2, group = group, colour = group)) +
  #geom_point() +
  stat_ellipse(type = "norm", level = 0.4, lwd = 1.5) +
  theme_classic(base_size = 14) +
  facet_wrap(~community) +
  labs(title = "40% Ellipse")

```

```{r Bayesian}
# Fit the Bayesian models
library(rjags)

# options for running jags
parms <- list()
parms$n.iter <- 2 * 10^4   # number of iterations to run the model for
parms$n.burnin <- 1 * 10^3 # discard the first set of values
parms$n.thin <- 10     # thin the posterior by this many
parms$n.chains <- 2        # run this many chains

# define the priors
priors <- list()
priors$R <- 1 * diag(2)
priors$k <- 2
priors$tau.mu <- 1.0E-3

# fit the ellipses which uses an Inverse Wishart prior
# on the covariance matrix Sigma, and a vague normal prior on the 
# means. Fitting is via the JAGS method.
ellipses.posterior <- siberMVN(siber.obj, parms, priors)


# extract the posterior means
mu.post <- extractPosteriorMeans(siber.obj, ellipses.posterior)

# calculate the corresponding distribution of layman metrics
layman.B <- bayesianLayman(mu.post)


# --------------------------------------
# Visualise the first community
# --------------------------------------

# drop the 3rd column of the posterior which is TA using -3.
siberDensityPlot(layman.B[[1]][ , -3], 
                 xticklabels = colnames(layman.B[[1]][ , -3]), 
                 bty="L", ylim = c(0,20))

# add the ML estimates (if you want). Extract the correct means 
# from the appropriate array held within the overall array of means.
comm1.layman.ml <- laymanMetrics(siber.obj$ML.mu[[1]][1,1,],
                                 siber.obj$ML.mu[[1]][1,2,]
                                 )

# again drop the 3rd entry which relates to TA
points(1:5, comm1.layman.ml$metrics[-3], 
       col = "red", pch = "x", lwd = 2)

# --------------------------------------
# Visualise the second community
# --------------------------------------
siberDensityPlot(layman.B[[2]][ , -3], 
                 xticklabels = colnames(layman.B[[2]][ , -3]), 
                bty="L", ylim = c(0,20))

# add the ML estimates. (if you want) Extract the correct means 
# from the appropriate array held within the overall array of means.
comm2.layman.ml <- laymanMetrics(siber.obj$ML.mu[[2]][1,1,],
                                 siber.obj$ML.mu[[2]][1,2,]
                                )
points(1:5, comm2.layman.ml$metrics[-3], 
       col = "red", pch = "x", lwd = 2)

# --------------------------------------
# Alternatively, pull out TA from both and aggregate them into a 
# single matrix using cbind() and plot them together on one graph.
# --------------------------------------

# go back to a 1x1 panel plot
par(mfrow=c(1,1))

# Now we only plot the TA data. We could address this as either
# layman.B[[1]][, "TA"]
# or
# layman.B[[1]][, 3]
siberDensityPlot(cbind(layman.B[[1]][ , "TA"], 
                       layman.B[[2]][ , "TA"]),
                xticklabels = c("Community 1", "Community 2"), 
                bty="L", ylim = c(0, 90),
                las = 1,
                ylab = "TA - Convex Hull Area",
                xlab = "")
```
